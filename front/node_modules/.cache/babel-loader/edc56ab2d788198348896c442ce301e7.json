{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nimport { states as recorderStates } from './constants/recorder';\nimport { recordings as recordingsSvc } from './services';\nconst {\n  RECORDING,\n  RESUMING,\n  PAUSED,\n  INACTIVE\n} = recorderStates;\n\nconst useRecorder = () => {\n  _s();\n\n  const [recordings, setRecordings] = useState([]);\n  const [recorderState, setRecorderState] = useState(INACTIVE);\n  const [recorder, setRecorder] = useState(null); // 👷 WIP: save stream to stop all tracks by getTracks()[0].stop()\n  // causing a 🐛 because of tracks removal?\n\n  const [stream, setStream] = useState();\n\n  const requestRecorder = () => navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n\n  const updateRecorderState = () => {\n    const recorderActions = {\n      inactive: () => recorder.stop(),\n      paused: () => recorder.pause(),\n      recording: () => recorder.start(),\n      resuming: () => recorder.resume()\n    };\n    recorderActions[recorderState]();\n  };\n\n  const startRecording = () => {\n    setRecorderState(RECORDING);\n  };\n\n  const resumeRecording = () => {\n    setRecorderState(RESUMING);\n  };\n\n  const pauseRecording = () => {\n    setRecorderState(PAUSED);\n  };\n\n  const stopRecording = () => {\n    setRecorderState(INACTIVE);\n  };\n\n  useEffect(() => {\n    recordingsSvc.get().then(data => {\n      console.log('resp', data);\n      setRecordings([...recordings, ...data]);\n    });\n\n    if (recorder === null) {\n      if (recorderState === RECORDING) {\n        requestRecorder().then(newStream => {\n          setStream(newStream);\n          setRecorder(new MediaRecorder(newStream));\n        }, console.error);\n      }\n\n      return;\n    }\n\n    updateRecorderState();\n\n    const handleData = e => {\n      const newRecording = URL.createObjectURL(e.data);\n      setRecordings([...recordings, newRecording]);\n    };\n\n    recorder.addEventListener('dataavailable', handleData);\n    return () => recorder.removeEventListener('dataavailable', handleData);\n  }, [recorder, recorderState]);\n  return [recordings, recorderState, startRecording, pauseRecording, resumeRecording, stopRecording];\n};\n\n_s(useRecorder, \"cZGDxnU1ybqeG59ZlP28Kxc0zPE=\");\n\nexport default useRecorder;","map":{"version":3,"sources":["/Users/gmore/Sites/blablabla/src/useRecorder.js"],"names":["useEffect","useState","states","recorderStates","recordings","recordingsSvc","RECORDING","RESUMING","PAUSED","INACTIVE","useRecorder","setRecordings","recorderState","setRecorderState","recorder","setRecorder","stream","setStream","requestRecorder","navigator","mediaDevices","getUserMedia","audio","updateRecorderState","recorderActions","inactive","stop","paused","pause","recording","start","resuming","resume","startRecording","resumeRecording","pauseRecording","stopRecording","get","then","data","console","log","newStream","MediaRecorder","error","handleData","e","newRecording","URL","createObjectURL","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react';\nimport { states as recorderStates } from './constants/recorder';\nimport { recordings as recordingsSvc } from './services';\n\nconst { RECORDING, RESUMING, PAUSED, INACTIVE } = recorderStates;\n\nconst useRecorder = () => {\n  const [recordings, setRecordings] = useState([]);\n  const [recorderState, setRecorderState] = useState(INACTIVE);\n  const [recorder, setRecorder] = useState(null);\n  // 👷 WIP: save stream to stop all tracks by getTracks()[0].stop()\n  // causing a 🐛 because of tracks removal?\n  const [stream, setStream] = useState();\n\n  const requestRecorder = () => (\n    navigator.mediaDevices.getUserMedia({ audio: true })\n  );\n\n  const updateRecorderState = () => {\n    const recorderActions = {\n      inactive: () => recorder.stop(),\n      paused: () => recorder.pause(),\n      recording: () => recorder.start(),\n      resuming: () => recorder.resume()\n    };\n    recorderActions[recorderState]();\n  };\n\n  const startRecording = () => {\n    setRecorderState(RECORDING);\n  };\n\n  const resumeRecording = () => {\n    setRecorderState(RESUMING);\n  };\n\n  const pauseRecording = () => {\n    setRecorderState(PAUSED);\n  };\n\n  const stopRecording = () => {\n    setRecorderState(INACTIVE);\n  };\n\n  useEffect(() => {\n    recordingsSvc\n      .get()\n      .then(data => {\n        console.log('resp', data);\n        setRecordings([\n          ...recordings,\n          ...data\n        ])\n      });\n\n    if (recorder === null) {\n      if (recorderState === RECORDING) {\n        requestRecorder().then(newStream => {\n          setStream(newStream)\n          setRecorder(new MediaRecorder(newStream));\n        }, console.error);\n      }\n      return;\n    }\n\n    updateRecorderState();\n\n    const handleData = e => {\n      const newRecording = URL.createObjectURL(e.data);\n\n      setRecordings([...recordings, newRecording]);\n    };\n\n    recorder.addEventListener('dataavailable', handleData);\n\n    return () => recorder.removeEventListener('dataavailable', handleData);\n  }, [recorder, recorderState]);\n\n  return [\n    recordings,\n    recorderState,\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording\n  ];\n};\n\nexport default useRecorder;\n"]},"metadata":{},"sourceType":"module"}